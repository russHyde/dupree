###############################################################################


###############################################################################

#' Strips comments from first '#' to end of line
#'
#' If a hash-symbol is present on a line, remove both it and any preceding
#'   spaces/tabs and any subsequent symbols.
#' Retain the newline characters.
#' Note that '.' does not match \\n.
#' TODO: Deal with quoted # characters
#'
#' @param        x             Some character vector
#'
#' @return       The same vector, but with any # ..... \n comments replaced
#'   with just a newline.
#'
#' @importFrom   stringr       str_replace_all
#'
.decomment <- function(x) {
  stopifnot(is.vector(x) && is.character(x))

  stringr::str_replace_all(x, "[[:blank:]]*#.*", "")
}

###############################################################################

#' Extracts code-blocks from the source-expressions returned by lintr
#'
#' @param        source_exprs   Source-expressions data-structure as returned
#'   by lintr::get_source_expressions.
#'
#' @importFrom   magrittr      %>%
#' @importFrom   purrr         map
#' @importFrom   stringr       str_replace_all
#'
#' @include      dupree_data_validity.R
#' @export
#'
parse_code_blocks <- function(source_exprs) {
  # source_exprs should have been generated by lintr::get_source_expressions
  stopifnot(
    .is_source_expressions_object(source_exprs)
  )


  .get_content <- function(x) {
    if (.has_content(x) && .has_parsed_content(x)) {
      x[["content"]]
    } else {
      ""
    }
  }

  code_blocks <- source_exprs[["expressions"]] %>%
    purrr::map(.get_content) %>%
    purrr::map(.decomment) %>%
    unlist() %>%
    stringr::str_replace_all("\\s", "")
}

###############################################################################

#' Runs an alignment between all code blocks
#'
#' For each block, it returns the index of the code block with the highest
#' similarity and the alignment score based on local-alignment using
#' pairwiseAlignment from Biostrings. Code blocks with fewer than `min_length`
#' characters are not included in the analysis
#'
#' @param        code_blocks   A vector of characters. If generated using the
#'   standard workflow, each entry should correspond to a block of code in the
#'   original R script and should have no whitespace or comments present.
#'
#' @param        min_length    A non-negative integer. Only code-blocks that
#'   have at least this many characters are used in the alignment step.
#'
#' @importFrom   Biostrings    pairwiseAlignment   score
#' @importFrom   dplyr         arrange   bind_rows   desc
#' @importFrom   magrittr      %>%
#' @importFrom   purrr         map
#' @importFrom   tibble        tibble
#'
#' @export
#'
compare_code_blocks <- function(
                                code_blocks,
                                min_length = 20) {
  # TODO: test this function

  stopifnot(
    is.vector(code_blocks) &&
      is.character(code_blocks)
  )
  stopifnot(is.numeric(min_length))

  keep_block_ids <- which(nchar(code_blocks) >= min_length)
  filtered_blocks <- code_blocks[keep_block_ids]

  message(
    stringr::str_interp(
      "Comparing ${length(keep_block_ids)} code blocks."
    )
  )

  .compute_best_alignment <- function(i) {
    pattern_idxs <- seq_along(filtered_blocks)[-i]

    aligns <- Biostrings::pairwiseAlignment(
      filtered_blocks[pattern_idxs],
      filtered_blocks[i],
      type = "local"
    )

    score_df <- tibble::tibble(
      score = Biostrings::score(aligns),
      subject = i,
      pattern = pattern_idxs
    )

    score_df[which.max(score_df$score), ]
  }

  dup_scores <- parallel::mclapply(
    seq_along(filtered_blocks),
    function(filtered_idx) {
      # Best block-block alignment relative to indices in the filtered code
      # blocks
      best_align <- .compute_best_alignment(filtered_idx)
      # Convert back to initial code-block indices
      best_align$subject <- keep_block_ids[filtered_idx]
      best_align$pattern <- keep_block_ids[best_align$pattern]
      best_align
    }
  ) %>%
    dplyr::bind_rows() %>%
    dplyr::arrange(dplyr::desc(score))

  list(
    scores = dup_scores,
    blocks = code_blocks
  )
}

###############################################################################

# Workflow for a set of files:
# - for each file:
#     - `get_source_expressions` on the file
#     - drop any entry in `expressions` that stores the whole file
#     - join the parsed_content blocks by block-number
# - join the file-level parsed-content blocks by file-name
# - filter the tokens to non-trivial symbols
#     - drop any blocks that have fewer non-trivial symbols than some threshold
# - enumerate the symbols
# - construct a vector of enumerated-symbols for each code-block in each file
# - run levenshtein distance between each pair of enumerated code blocks
# - return the distance-sorted associations between blocks

# Therefore, need class:
#   - `EnumeratedCodeTable`: tibble containing colnames "file", "block",
#   "start_line", "enumerated_code"
#   - the "enumerated_code" column is a list of vectors of integers
#   - methods: find_best_matches() and find_best_matches_of_single_block()

# Also need a way to filter out blocks that have few non-trivial symbols

###############################################################################

#' Duplicate detection workflow
#'
#' @param        file          Some filename. Should be an R script or
#'   R-markdown file (or similar file parseable by lintr).
#'
#' @inheritParams   compare_code_blocks
#'
#' @importFrom   lintr         get_source_expressions
#' @importFrom   magrittr      %>%
#'
#' @export

dupr <- function(
                 file,
                 min_length = 20) {
  lintr::get_source_expressions(file) %>%
    parse_code_blocks() %>%
    compare_code_blocks(min_length = min_length)
}

###############################################################################

#' Newer version of the duplicate detection workflow
#'
#' @export

dupree <- function(files, min_block_size = 5, ...) {
  preprocess_code_blocks(files, min_block_size) %>%
    find_best_matches()
}
